---
title: "Multivariate Analysis of CBD Logistics Survey: UCC Implementation Strategy"
author: "cagranadam"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_float: true
    theme: flatly
    code_folding: hide
    fig_width: 12
    fig_height: 8
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE, 
  warning = FALSE, 
  message = FALSE,
  fig.align = "center",
  cache = FALSE
)
```

# 1. Introduction

This document addresses the research question:

> **RQ:** What are the specific logistics needs within Central Business Districts (CBDs), and how can alignment of supply and demand among urban establishments inform strategic implementation of Urban Consolidation Centers (UCCs) in Low Emission Zones (LEZs)?

**Methodological Approach:** Factor Analysis of Mixed Data (FAMD) → Cluster Analysis → Strategic UCC Implementation Framework

# 2. Setup & Data Import

## 2.1 Load Required Libraries

```{r libraries}
# Load required packages with error handling
required_packages <- c("readr", "dplyr", "tidyr", "psych", "ggplot2", 
                      "cluster", "factoextra", "FactoMineR", "tibble", 
                      "knitr", "DT", "corrplot", "plotly", "scales",
                      "ca", "purrr", "stringr", "forcats", "gridExtra",
                      "VIM", "mice", "pheatmap", "RColorBrewer", "janitor")

# Function to install and load packages
load_packages <- function(packages) {
  for (pkg in packages) {
    if (!require(pkg, character.only = TRUE)) {
      install.packages(pkg, dependencies = TRUE)
      library(pkg, character.only = TRUE)
    }
  }
}

load_packages(required_packages)

# Set ggplot theme
theme_set(theme_minimal(base_size = 12))
```

## 2.2 Data Import from Python Pipeline

```{r data_import}
# Load main cleaned dataset
survey_data <- read_csv("../../data/intermediate/cleaned_survey_for_r.csv", 
                       locale = locale(encoding = "UTF-8"),
                       show_col_types = FALSE)

# Load processed analysis datasets
datasets <- list(
  temporal = read_csv("../../data/intermediate/temporal_analysis_for_r.csv", show_col_types = FALSE),
  transport_mode = read_csv("../../data/intermediate/transportation_mode_for_r.csv", show_col_types = FALSE),
  unloading_location = read_csv("../../data/intermediate/unloading_location_for_r.csv", show_col_types = FALSE),
  unloading_equipment = read_csv("../../data/intermediate/unloading_equipment_for_r.csv", show_col_types = FALSE),
  supply_frequency = read_csv("../../data/intermediate/supply_frequency_for_r.csv", show_col_types = FALSE),
  warehouse_ownership = read_csv("../../data/intermediate/warehouse_ownership_for_r.csv", show_col_types = FALSE),
  warehouse_zuap = read_csv("../../data/intermediate/warehouse_in_zuap_for_r.csv", show_col_types = FALSE),
  ecommerce_deliveries = read_csv("../../data/intermediate/ecommerce_deliveries_for_r.csv", show_col_types = FALSE),
  traditional_deliveries = read_csv("../../data/intermediate/traditional_deliveries_for_r.csv", show_col_types = FALSE),
  supply_perception = read_csv("../../data/intermediate/supply_perception_for_r.csv", show_col_types = FALSE),
  bike_perception = read_csv("../../data/intermediate/bike_perception_for_r.csv", show_col_types = FALSE)
)

cat("✓ Main dataset loaded:", nrow(survey_data), "rows,", ncol(survey_data), "columns\n")
cat("✓ Processed datasets loaded:", length(datasets), "analysis matrices\n")

# Validate that processed datasets were loaded successfully
for(dataset_name in names(datasets)) {
  if(nrow(datasets[[dataset_name]]) > 0) {
    cat("  -", dataset_name, ":", nrow(datasets[[dataset_name]]), "rows ×", ncol(datasets[[dataset_name]]), "columns\n")
  } else {
    cat("  - ⚠️", dataset_name, ": EMPTY or FAILED to load\n")
  }
}
```

```{r}
glimpse(survey_data)
```

### Identified columns in datasets for modelling
```{r column_identification}
# Examine the structure of the main survey dataset
cat("=== MAIN SURVEY DATASET STRUCTURE ===\n")
cat("Dimensions:", nrow(survey_data), "rows ×", ncol(survey_data), "columns\n\n")

# Display column names and types
main_columns <- data.frame(
  Column = names(survey_data),
  Type = sapply(survey_data, class),
  Sample_Values = sapply(survey_data, function(x) {
    if(is.numeric(x)) {
      paste(round(range(x, na.rm = TRUE), 2), collapse = " - ")
    } else {
      paste(unique(x)[1:min(3, length(unique(x)))], collapse = ", ")
    }
  }),
  Missing_Count = sapply(survey_data, function(x) sum(is.na(x))),
  stringsAsFactors = FALSE
)

kable(main_columns, 
      caption = "Main Survey Dataset - Column Overview",
      col.names = c("Column Name", "Data Type", "Sample Values/Range", "Missing Values"))

# Examine the structure of each processed dataset
cat("\n=== PROCESSED DATASETS OVERVIEW ===\n")
for(dataset_name in names(datasets)) {
  dataset <- datasets[[dataset_name]]
  cat("\n**", toupper(gsub("_", " ", dataset_name)), "DATASET:**\n")
  cat("- Dimensions:", nrow(dataset), "rows ×", ncol(dataset), "columns\n")
  cat("- Columns:", paste(names(dataset), collapse = ", "), "\n")
  
  # Check for numeric vs categorical columns
  numeric_cols <- names(dataset)[sapply(dataset, is.numeric)]
  categorical_cols <- names(dataset)[!sapply(dataset, is.numeric)]
  
  if(length(numeric_cols) > 0) {
    cat("- Numeric columns:", paste(numeric_cols, collapse = ", "), "\n")
  }
  if(length(categorical_cols) > 0) {
    cat("- Categorical columns:", paste(categorical_cols, collapse = ", "), "\n")
  }
}

# Identify potential modeling variables
cat("\n=== MODELING VARIABLE IDENTIFICATION ===\n")

# Separate variables by type for modeling
numeric_vars <- names(survey_data)[sapply(survey_data, is.numeric)]
character_vars <- names(survey_data)[sapply(survey_data, is.character)]
factor_vars <- names(survey_data)[sapply(survey_data, is.factor)]

cat("**NUMERIC VARIABLES (", length(numeric_vars), "):**\n")
cat(paste(numeric_vars, collapse = ", "), "\n\n")

cat("**CHARACTER VARIABLES (", length(character_vars), "):**\n") 
cat(paste(character_vars, collapse = ", "), "\n\n")

if(length(factor_vars) > 0) {
  cat("**FACTOR VARIABLES (", length(factor_vars), "):**\n")
  cat(paste(factor_vars, collapse = ", "), "\n\n")
}

# Identify key variables for different analyses
cat("**RECOMMENDED VARIABLES FOR DIFFERENT ANALYSES:**\n\n")

# For Factor Analysis (numeric only)
fa_candidates <- numeric_vars[!is.na(numeric_vars)]
cat("- **Factor Analysis candidates:** ", paste(fa_candidates, collapse = ", "), "\n")

# For FAMD (mixed data)
famd_candidates <- c(
  numeric_vars[1:min(3, length(numeric_vars))], # First few numeric
  character_vars[1:min(3, length(character_vars))] # First few categorical
)
cat("- **FAMD candidates:** ", paste(famd_candidates, collapse = ", "), "\n")

# For Correspondence Analysis (categorical)
ca_candidates <- character_vars[1:min(4, length(character_vars))]
cat("- **Correspondence Analysis candidates:** ", paste(ca_candidates, collapse = ", "), "\n")

# Check for key business variables
business_vars <- character_vars[grepl("activity|product|type|category", character_vars, ignore.case = TRUE)]
location_vars <- character_vars[grepl("location|address|zone|area", character_vars, ignore.case = TRUE)]
logistics_vars <- character_vars[grepl("transport|delivery|supply|warehouse|logistics", character_vars, ignore.case = TRUE)]

if(length(business_vars) > 0) {
  cat("- **Business characteristic variables:** ", paste(business_vars, collapse = ", "), "\n")
}
if(length(location_vars) > 0) {
  cat("- **Location variables:** ", paste(location_vars, collapse = ", "), "\n")
}
if(length(logistics_vars) > 0) {
  cat("- **Logistics variables:** ", paste(logistics_vars, collapse = ", "), "\n")
}

# Data quality summary
cat("\n**DATA QUALITY SUMMARY:**\n")
missing_summary <- survey_data %>%
  summarise_all(~sum(is.na(.))) %>%
  gather(key = "Variable", value = "Missing_Count") %>%
  arrange(desc(Missing_Count)) %>%
  slice_head(n = 5)

cat("Variables with most missing values:\n")
for(i in 1:nrow(missing_summary)) {
  cat("-", missing_summary$Variable[i], ":", missing_summary$Missing_Count[i], "missing\n")
}
```

### Raw Main Products Analysis
```{r raw_products_analysis}
# Detailed analysis of the main_products column to inform better categorization
if("main_products" %in% names(survey_data)) {
  
  # Clean and analyze raw main_products data
  raw_products_summary <- survey_data %>%
    filter(!is.na(main_products), trimws(main_products) != "") %>%
    mutate(main_products_clean_text = trimws(main_products)) %>%
    count(main_products_clean_text, sort = TRUE) %>%
    mutate(
      main_products_lower = str_to_lower(main_products_clean_text),
      percentage = round(n / sum(n) * 100, 1),
      cumulative_pct = round(cumsum(n) / sum(n) * 100, 1),
      # Current categorization rules
      current_category = case_when(
        str_detect(main_products_lower, "ropa|textil|confecci[oó]n") ~ "Clothing & Textiles",
        str_detect(main_products_lower, "calzado") ~ "Footwear", 
        str_detect(main_products_lower, "cosm[eé]tic|belleza") ~ "Cosmetics & Beauty",
        str_detect(main_products_lower, "alimento|comida") ~ "Food & Beverages",
        str_detect(main_products_lower, "electr[oó]nic|tecnolog") ~ "Electronics & Technology", 
        str_detect(main_products_lower, "reciclaje|residuos") ~ "Waste & Recycling",
        str_detect(main_products_lower, "manufactur") ~ "Manufacturing",
        str_detect(main_products_lower, "papel|oficina") ~ "Office Supplies",
        TRUE ~ "Other Products"
      ),
      # Identify potential new categories from most common "Other Products"
      potential_new_category = case_when(
        str_detect(main_products_lower, "joyeria|joyas|bijouterie") ~ "Jewelry & Accessories",
        str_detect(main_products_lower, "farmacia|medicamento|drogueria") ~ "Pharmacy & Medical",
        str_detect(main_products_lower, "optica|lentes|gafas") ~ "Optical & Eyewear",
        str_detect(main_products_lower, "ferreteria|herramienta|materiales") ~ "Hardware & Tools",
        str_detect(main_products_lower, "libreria|libro|papeleria") ~ "Books & Stationery",
        str_detect(main_products_lower, "decoracion|muebles|hogar") ~ "Home & Decoration",
        str_detect(main_products_lower, "telefon|celular|comunicacion") ~ "Telecommunications",
        str_detect(main_products_lower, "deportes|fitness|gym") ~ "Sports & Fitness",
        str_detect(main_products_lower, "vehiculo|moto|automotriz") ~ "Automotive",
        str_detect(main_products_lower, "mascotas|veterinaria|animales") ~ "Pet Care",
        str_detect(main_products_lower, "servicios|reparacion") ~ "Services",
        TRUE ~ current_category
      )
    )
  
  # Summary statistics
  cat("=== RAW MAIN_PRODUCTS DETAILED ANALYSIS ===\n")
  cat("Total unique products:", nrow(raw_products_summary), "\n")
  cat("Total observations:", sum(raw_products_summary$n), "\n")
  
  # Current categorization results
  current_cat_summary <- raw_products_summary %>%
    group_by(current_category) %>%
    summarise(
      unique_products = n(),
      total_observations = sum(n),
      percentage = round(sum(n) / sum(raw_products_summary$n) * 100, 1)
    ) %>%
    arrange(desc(total_observations))
  
  cat("\nCURRENT CATEGORIZATION RESULTS:\n")
  kable(current_cat_summary, 
        caption = "Current Product Categorization Distribution",
        col.names = c("Category", "Unique Products", "Observations", "Percentage (%)"))
  
  # Show products currently falling into "Other Products"
  other_products <- raw_products_summary %>%
    filter(current_category == "Other Products") %>%
    arrange(desc(n)) %>%
    slice_head(n = 25)
  
  cat("\nTOP 25 PRODUCTS CURRENTLY CATEGORIZED AS 'OTHER PRODUCTS':\n")
  if(nrow(other_products) > 0) {
    for(i in 1:nrow(other_products)) {
      cat(sprintf("%2d. %-50s (%2d obs, %2.1f%%) -> %s\n", 
                 i, 
                 other_products$main_products_clean_text[i], 
                 other_products$n[i],
                 other_products$percentage[i],
                 other_products$potential_new_category[i]))
    }
  } else {
    cat("No products falling into 'Other Products' category.\n")
  }
  
  # Potential new categorization results
  new_cat_summary <- raw_products_summary %>%
    group_by(potential_new_category) %>%
    summarise(
      unique_products = n(),
      total_observations = sum(n),
      percentage = round(sum(n) / sum(raw_products_summary$n) * 100, 1)
    ) %>%
    arrange(desc(total_observations))
  
  cat("\nPOTENTIAL IMPROVED CATEGORIZATION RESULTS:\n")
  kable(new_cat_summary, 
        caption = "Potential Improved Product Categorization Distribution",
        col.names = c("Category", "Unique Products", "Observations", "Percentage (%)"))
  
  # Show the most frequent raw products overall
  cat("\nTOP 20 MOST FREQUENT RAW PRODUCTS:\n")
  top_products <- head(raw_products_summary, 20)
  for(i in 1:nrow(top_products)) {
    cat(sprintf("%2d. %-50s (%2d obs, %2.1f%%, cum: %2.1f%%)\n", 
               i, 
               top_products$main_products_clean_text[i], 
               top_products$n[i],
               top_products$percentage[i],
               top_products$cumulative_pct[i]))
  }
  
  # Calculate improvement in categorization
  current_other_pct <- current_cat_summary$percentage[current_cat_summary$current_category == "Other Products"]
  new_other_pct <- new_cat_summary$percentage[new_cat_summary$potential_new_category == "Other Products"]
  
  if(length(current_other_pct) > 0 && length(new_other_pct) > 0) {
    cat(sprintf("\nCATEGORIZATION IMPROVEMENT:\n"))
    cat(sprintf("- Current 'Other Products': %2.1f%%\n", current_other_pct))
    cat(sprintf("- Improved 'Other Products': %2.1f%%\n", new_other_pct)) 
    cat(sprintf("- Reduction in 'Other': %2.1f percentage points\n", current_other_pct - new_other_pct))
  }
  
  # Store analysis for use in enhanced categorization
  assign("products_analysis_result", raw_products_summary, envir = .GlobalEnv)
  
} else {
  cat("main_products column not found in survey_data\n")
}
```

## 2.3 Data Preparation for Multivariate Analysis

```{r data_preparation}
# Load additional packages for improved data preparation
library(janitor)
#AAas
# Define helper vectors for data types
structural_zero_vars <- c("num_deliveries", "num_online_deliveries", 
                         "female_employees", "female_emplo_distri", 
                         "number_warehouse")

numeric_vars <- c("employees", structural_zero_vars, "warehouse_area", 
                 "warehouse_height")

# Enhanced data preparation pipeline
famd_data <- survey_data %>% 
  janitor::clean_names() %>%                                   # Convert to snake_case
  mutate(across(everything(), ~na_if(trimws(.x), ""))) %>%     # Convert empty strings to NA
  
  # Convert structural zero variables to numeric first, then handle NAs
  mutate(across(all_of(structural_zero_vars), ~as.numeric(.x))) %>%
  
  # Keep structural zeros explicit (important for logistics data)
  mutate(across(all_of(structural_zero_vars), ~replace_na(.x, 0))) %>% 
  
  # Enhanced categorical recoding with factors
  mutate(
    # Establishment type with proper factor levels
    est_type = case_when(
      str_detect(str_to_lower(economic_activity), "proveedor")        ~ "Supplier",
      str_detect(str_to_lower(economic_activity), "venta al detalle") ~ "Retailer",
      str_detect(str_to_lower(economic_activity), "fabricante")       ~ "Manufacturer",
      str_detect(str_to_lower(economic_activity), "internet")         ~ "E-commerce",
      TRUE                                                            ~ "Other"
    ) %>% factor(levels = c("Retailer", "Supplier", "Manufacturer", "E-commerce", "Other")),
    
    # Warehouse indicators with proper handling
    has_warehouse = case_when(
      str_detect(str_to_lower(warehouse), "no") ~ "No",
      str_detect(str_to_lower(warehouse), "interno") ~ "Internal",
      str_detect(str_to_lower(warehouse), "externo") ~ "External", 
      TRUE ~ "Mixed"
    ) %>% factor(levels = c("No", "Internal", "External", "Mixed")),
    
    warehouse_in_zuap = case_when(
      str_detect(str_to_lower(zuap_warehouse), "sí|si|yes") ~ "Yes",
      str_detect(str_to_lower(zuap_warehouse), "no") ~ "No",
      TRUE ~ "Unknown"
    ) %>% factor(levels = c("No", "Yes", "Unknown")),
    
    # Ordinal safety perception variables with proper cuts
    safety_level = cut(as.numeric(supply_safety_percep),
                       breaks = c(-Inf, 2, 3, Inf),
                       labels = c("Low", "Medium", "High"),
                       ordered_result = TRUE),
    
    bike_safety_level = cut(as.numeric(supply_bic_safety_perception),
                            breaks = c(-Inf, 2, 3, Inf),
                            labels = c("Low", "Medium", "High"),
                            ordered_result = TRUE),
    
    # Enhanced activity classification
    specific_activity_clean = case_when(
      str_detect(str_to_lower(specific_activity), "fabricaci[oó]n") ~ "Manufacturing",
      str_detect(str_to_lower(specific_activity), "recolecci[oó]n") ~ "Waste Collection",
      str_detect(str_to_lower(specific_activity), "servicio")       ~ "Services",
      str_detect(str_to_lower(specific_activity), "venta de")       ~ "Retail Sales",
      str_detect(str_to_lower(specific_activity), "distribuci[oó]n") ~ "Distribution",
      !is.na(specific_activity) & specific_activity != ""           ~ "Other Commercial",
      TRUE                                                          ~ "Other"
    ) %>% factor(),
    
    # First, let's analyze the raw main_products column to understand what we're categorizing
    temp_products_analysis = if(exists("main_products") && length(unique(main_products[!is.na(main_products)])) > 0) {
      # Create a temporary analysis of raw products
      raw_products_summary <- survey_data %>%
        filter(!is.na(main_products), main_products != "") %>%
        count(main_products, sort = TRUE) %>%
        mutate(
          main_products_lower = str_to_lower(main_products),
          percentage = round(n / sum(n) * 100, 1),
          # Identify what would fall into "Other Products" with current rules
          current_category = case_when(
            str_detect(main_products_lower, "ropa|textil|confecci[oó]n") ~ "Clothing & Textiles",
            str_detect(main_products_lower, "calzado")                   ~ "Footwear", 
            str_detect(main_products_lower, "cosm[eé]tic|belleza")       ~ "Cosmetics & Beauty",
            str_detect(main_products_lower, "alimento|comida")           ~ "Food & Beverages",
            str_detect(main_products_lower, "electr[oó]nic|tecnolog")    ~ "Electronics & Technology",
            str_detect(main_products_lower, "reciclaje|residuos")        ~ "Waste & Recycling",
            str_detect(main_products_lower, "manufactur")                ~ "Manufacturing",
            str_detect(main_products_lower, "papel|oficina")             ~ "Office Supplies",
            TRUE                                                        ~ "Other Products"
          )
        )
      
      # Print analysis results
      cat("=== RAW MAIN_PRODUCTS ANALYSIS ===\n")
      cat("Total unique products:", nrow(raw_products_summary), "\n")
      cat("Products falling into 'Other Products':", sum(raw_products_summary$current_category == "Other Products"), "\n")
      cat("Percentage of data in 'Other Products':", round(sum(raw_products_summary$n[raw_products_summary$current_category == "Other Products"]) / sum(raw_products_summary$n) * 100, 1), "%\n\n")
      
      # Show top 20 raw products and their current categorization
      cat("TOP 20 RAW PRODUCTS AND CURRENT CATEGORIZATION:\n")
      top_products <- head(raw_products_summary, 20)
      for(i in 1:nrow(top_products)) {
        cat(sprintf("%2d. %-40s (%2d%%) -> %s\n", 
                   i, 
                   top_products$main_products[i], 
                   top_products$percentage[i],
                   top_products$current_category[i]))
      }
      
      # Show specifically what's falling into "Other Products"
      cat("\nPRODUCTS CURRENTLY CATEGORIZED AS 'OTHER PRODUCTS':\n")
      other_products <- raw_products_summary %>%
        filter(current_category == "Other Products") %>%
        arrange(desc(n))
      
      if(nrow(other_products) > 0) {
        for(i in 1:min(nrow(other_products), 15)) {
          cat(sprintf("%2d. %-40s (%2d observations, %2.1f%%)\n", 
                     i, 
                     other_products$main_products[i], 
                     other_products$n[i],
                     other_products$percentage[i]))
        }
      } else {
        cat("No products falling into 'Other Products' category.\n")
      }
      
      # Return the analysis for potential use
      raw_products_summary
    } else {
      cat("main_products column not found or empty\n")
      NULL
    },

    # Enhanced product categorization based on raw data analysis
    main_products_clean = case_when(
      # Original core categories
      str_detect(str_to_lower(main_products), "ropa|textil|confecci[oó]n") ~ "Clothing & Textiles",
      str_detect(str_to_lower(main_products), "calzado") ~ "Footwear",
      str_detect(str_to_lower(main_products), "cosm[eé]tic|belleza") ~ "Cosmetics & Beauty",
      str_detect(str_to_lower(main_products), "alimento|comida") ~ "Food & Beverages",
      str_detect(str_to_lower(main_products), "electr[oó]nic|tecnolog") ~ "Electronics & Technology",
      str_detect(str_to_lower(main_products), "reciclaje|residuos") ~ "Waste & Recycling",
      str_detect(str_to_lower(main_products), "manufactur") ~ "Manufacturing",
      str_detect(str_to_lower(main_products), "papel|oficina") ~ "Office Supplies",
      
      # New categories identified from analysis to reduce "Other Products"
      str_detect(str_to_lower(main_products), "joyeria|joyas|bijouterie|accesorio") ~ "Jewelry & Accessories",
      str_detect(str_to_lower(main_products), "farmacia|medicamento|drogueria|salud") ~ "Pharmacy & Medical",
      str_detect(str_to_lower(main_products), "optica|lentes|gafas|visual") ~ "Optical & Eyewear",
      str_detect(str_to_lower(main_products), "ferreteria|herramienta|materiales|construcción") ~ "Hardware & Tools",
      str_detect(str_to_lower(main_products), "libreria|libro|papeleria|educacion") ~ "Books & Stationery",
      str_detect(str_to_lower(main_products), "decoracion|muebles|hogar|casa") ~ "Home & Decoration",
      str_detect(str_to_lower(main_products), "telefon|celular|comunicacion|movil") ~ "Telecommunications",
      str_detect(str_to_lower(main_products), "deportes|fitness|gym|deportivo") ~ "Sports & Fitness",
      str_detect(str_to_lower(main_products), "vehiculo|moto|automotriz|auto|carro") ~ "Automotive",
      str_detect(str_to_lower(main_products), "mascotas|veterinaria|animales|pet") ~ "Pet Care",
      str_detect(str_to_lower(main_products), "servicios|reparacion|mantenimiento") ~ "Services",
      
      # Keep for valid non-empty products not captured above
      !is.na(main_products) & main_products != "" ~ "Other Products",
      TRUE ~ "Other"
    ) %>% factor(),
    
    # Warehouse floor as ordinal (floor levels matter for logistics)
    warehouse_floor_ord = case_when(
      is.na(warehouse_floor) ~ NA_character_,
      warehouse_floor <= 1 ~ "Ground Floor",
      warehouse_floor <= 3 ~ "Low Floor (2-3)",
      warehouse_floor <= 5 ~ "Mid Floor (4-5)",
      TRUE ~ "High Floor (6+)"
    ) %>% factor(levels = c("Ground Floor", "Low Floor (2-3)", "Mid Floor (4-5)", "High Floor (6+)"), 
                 ordered = TRUE)
  ) %>% 
  
  # Ordinal conversion and normalization
  mutate(
    # Parse supply frequency properly
    supply_week_num = case_when(
      str_detect(str_to_lower(supply_week), "1") ~ 1L,
      str_detect(str_to_lower(supply_week), "2") ~ 2L,
      str_detect(str_to_lower(supply_week), "3") ~ 3L,
      str_detect(str_to_lower(supply_week), "4") ~ 4L,
      str_detect(str_to_lower(supply_week), "5") ~ 5L,
      str_detect(str_to_lower(supply_week), "6|más") ~ 6L,
      TRUE ~ 3L  # median value for missing
    ),
    
    # Create size categories for employees
    establishment_size = case_when(
      employees <= 3 ~ "Micro (1-3)",
      employees <= 10 ~ "Small (4-10)", 
      employees <= 25 ~ "Medium (11-25)",
      TRUE ~ "Large (26+)"
    ) %>% factor(levels = c("Micro (1-3)", "Small (4-10)", "Medium (11-25)", "Large (26+)"), 
                 ordered = TRUE),
    
    # Normalize numeric variables (with proper handling of zeros)
    supply_week_norm = scale(supply_week_num)[, 1],
    across(all_of(numeric_vars), ~scale(as.numeric(.x))[, 1], .names = "{.col}_norm"),
    
    # Create logistics intensity indicators
    delivery_intensity = case_when(
      num_deliveries == 0 ~ "No Deliveries",
      num_deliveries <= 2 ~ "Low (1-2/day)",
      num_deliveries <= 5 ~ "Medium (3-5/day)",
      TRUE ~ "High (6+/day)"
    ) %>% factor(levels = c("No Deliveries", "Low (1-2/day)", "Medium (3-5/day)", "High (6+/day)"), 
                 ordered = TRUE),
    
    online_delivery_intensity = case_when(
      num_online_deliveries == 0 ~ "No Online",
      num_online_deliveries <= 2 ~ "Low Online",
      num_online_deliveries <= 5 ~ "Medium Online", 
      TRUE ~ "High Online"
    ) %>% factor(levels = c("No Online", "Low Online", "Medium Online", "High Online"), 
                 ordered = TRUE)
  ) %>% 
  
  # Select key variables for FAMD analysis
  select(
    # Categorical variables
    est_type, specific_activity_clean, main_products_clean,
    has_warehouse, warehouse_in_zuap, establishment_size,
    safety_level, bike_safety_level, warehouse_floor_ord,
    delivery_intensity, online_delivery_intensity,
    
    # Normalized numeric variables  
    employees_norm, num_deliveries_norm, num_online_deliveries_norm,
    female_employees_norm, female_emplo_distri_norm, number_warehouse_norm,
    warehouse_area_norm, warehouse_height_norm, supply_week_norm,
    
    # Original perception variables for reference
    supply_safety_percep, supply_bic_safety_perception
  ) %>% 
  
  # Remove incomplete cases only after all transformations
  filter(if_all(c(est_type, specific_activity_clean, main_products_clean, 
                  employees_norm, supply_week_norm, safety_level, bike_safety_level), 
                ~!is.na(.x)))

# Diagnostics and summary
cat("✓ FAMD dataset prepared:", nrow(famd_data), "complete observations\n")
cat("✓ Variables for analysis:\n")

# Categorize variables by type for analysis
categorical_vars <- famd_data %>% 
  select_if(is.factor) %>% 
  names()

numeric_analysis_vars <- famd_data %>% 
  select(ends_with("_norm")) %>% 
  names()

cat("  - Categorical variables (", length(categorical_vars), "):", 
    paste(categorical_vars, collapse = ", "), "\n")
cat("  - Normalized numeric variables (", length(numeric_analysis_vars), "):", 
    paste(numeric_analysis_vars, collapse = ", "), "\n")

# Data quality check
cat("\n✓ Data quality summary:\n")
cat("  - No missing values in core variables:", 
    sum(is.na(famd_data[categorical_vars])) == 0, "\n")
cat("  - Establishment types:", paste(levels(famd_data$est_type), collapse = ", "), "\n")
cat("  - Warehouse configurations:", paste(levels(famd_data$has_warehouse), collapse = ", "), "\n")
```

```{r}
# Enhanced product categorization
    main_products_clean = case_when(
      str_detect(str_to_lower(main_products)
```


# 3. Exploratory Data Analysis & Diagnostics

## 3.1 Data Quality Assessment

```{r data_quality}
# Check missing values and data structure
cat("=== DATA QUALITY ASSESSMENT ===\n")
cat("Dataset dimensions:", nrow(famd_data), "observations,", ncol(famd_data), "variables\n\n")

# Missing values analysis
missing_summary <- famd_data %>%
  summarise_all(~sum(is.na(.))) %>%
  gather(key = "Variable", value = "Missing_Count") %>%
  mutate(Missing_Percentage = round(Missing_Count / nrow(famd_data) * 100, 2)) %>%
  arrange(desc(Missing_Count))

kable(missing_summary, caption = "Missing Values Summary")

# Data types summary
str(famd_data)
```

## 3.2 Univariate Analysis & Normality Testing

```{r univariate_analysis}
#  Select numeric variables for normality testing
numeric_vars <- famd_data %>% 
  select_if(is.numeric) %>%
  # Remove perception variables if they exist
  select(-any_of(c("supply_safety_percep", "supply_bic_safety_perception")))

# Debug: Check what we actually have
cat("Columns in numeric_vars:", paste(names(numeric_vars), collapse = ", "), "\n")
cat("Data types:\n")
str(numeric_vars)

# Additional filtering to ensure only truly numeric columns
numeric_vars <- numeric_vars %>%
  select_if(function(x) is.numeric(x) && !is.factor(x) && !is.character(x))

cat("After additional filtering - Columns:", paste(names(numeric_vars), collapse = ", "), "\n")

if(ncol(numeric_vars) > 0) {
  # Remove any columns with all NA or infinite values
  numeric_vars <- numeric_vars %>%
    select_if(function(x) !all(is.na(x)) && !any(is.infinite(x)))
  
  cat("Final numeric columns:", paste(names(numeric_vars), collapse = ", "), "\n")
  
  if(ncol(numeric_vars) > 0) {
    # Histograms for numeric variables
    par(mfrow = c(1, min(ncol(numeric_vars), 3)))
    for(i in 1:ncol(numeric_vars)) {
      # Use [[i]] to extract actual vector from tibble
      col_data <- numeric_vars[[i]]
      col_data <- col_data[!is.na(col_data) & !is.infinite(col_data)]
      
      if(length(col_data) > 0) {
        hist(col_data, 
             main = paste("Histogram of", names(numeric_vars)[i]),
             xlab = names(numeric_vars)[i],
             col = "lightblue",
             breaks = min(20, length(unique(col_data))))
      }
    }
    
    # Q-Q plots for normality assessment
    par(mfrow = c(1, min(ncol(numeric_vars), 3)))
    for(i in 1:ncol(numeric_vars)) {
      col_data <- numeric_vars[[i]]
      col_data <- col_data[!is.na(col_data) & !is.infinite(col_data)]
      
      if(length(col_data) > 0) {
        qqnorm(col_data, main = paste("Q-Q Plot:", names(numeric_vars)[i]))
        qqline(col_data, col = "red")
      }
    }
    
    # Shapiro-Wilk normality tests
    if(ncol(numeric_vars) > 0) {
      normality_tests <- data.frame(
        Variable = character(0),
        Shapiro_Statistic = numeric(0),
        P_Value = numeric(0),
        Normal = character(0),
        stringsAsFactors = FALSE
      )
      
      for(i in 1:ncol(numeric_vars)) {
        col_data <- numeric_vars[[i]]
        col_data <- col_data[!is.na(col_data) & !is.infinite(col_data)]
        
        if(length(col_data) >= 3 && length(col_data) <= 5000) {  # Shapiro test limits
          test_result <- shapiro.test(col_data)
          normality_tests <- rbind(normality_tests, data.frame(
            Variable = names(numeric_vars)[i],
            Shapiro_Statistic = round(test_result$statistic, 4),
            P_Value = round(test_result$p.value, 4),
            Normal = ifelse(test_result$p.value > 0.05, "YES", "NO"),
            stringsAsFactors = FALSE
          ))
        } else {
          normality_tests <- rbind(normality_tests, data.frame(
            Variable = names(numeric_vars)[i],
            Shapiro_Statistic = NA,
            P_Value = NA,
            Normal = "Cannot test",
            stringsAsFactors = FALSE
          ))
        }
      }
      
      if(nrow(normality_tests) > 0) {
        kable(normality_tests, caption = "Normality Tests (H0: Normal Distribution)")
      } else {
        cat("No valid numeric variables for normality testing\n")
      }
    }
  } else {
    cat("No valid numeric columns found after filtering\n")
  }
} else {
  cat("No numeric variables found in the dataset\n")
}

# Reset plotting parameters
par(mfrow = c(1, 1))
```

## 3.3 Categorical Variables Analysis

```{r categorical_analysis}
# Analyze categorical variables distribution
cat("=== CATEGORICAL VARIABLES ANALYSIS ===\n")

# Specific Activity distribution
specific_activity_counts <- famd_data %>%
  count(specific_activity_clean, sort = TRUE) %>%
  filter(!is.na(specific_activity_clean)) %>%
  mutate(percentage = round(n / sum(n) * 100, 1))

kable(specific_activity_counts, 
      caption = "Distribution of Specific Activities",
      col.names = c("Specific Activity", "Count", "Percentage (%)"))

# Main Products distribution
main_products_counts <- famd_data %>%
  count(main_products_clean, sort = TRUE) %>%
  filter(!is.na(main_products_clean)) %>%
  mutate(percentage = round(n / sum(n) * 100, 1))

kable(main_products_counts, 
      caption = "Distribution of Main Products",
      col.names = c("Main Products", "Count", "Percentage (%)"))

# Visualizations
if(nrow(specific_activity_counts) > 1) {
  p1 <- ggplot(specific_activity_counts, aes(x = reorder(specific_activity_clean, n), y = n)) +
    geom_col(fill = "steelblue", alpha = 0.8) +
    coord_flip() +
    labs(title = "Distribution of Specific Activities",
         x = "Specific Activity", y = "Count") +
    theme_minimal()
  
  print(p1)
}

if(nrow(main_products_counts) > 1) {
  p2 <- ggplot(main_products_counts, aes(x = reorder(main_products_clean, n), y = n)) +
    geom_col(fill = "darkgreen", alpha = 0.8) +
    coord_flip() +
    labs(title = "Distribution of Main Products",
         x = "Main Products", y = "Count") +
    theme_minimal()
  
  print(p2)
}

# Cross-tabulation between establishment type and specific activity
if(sum(!is.na(famd_data$est_type)) > 0 && sum(!is.na(famd_data$specific_activity_clean)) > 0) {
  cross_tab <- xtabs(~ est_type + specific_activity_clean, data = famd_data)
  
  # Display only if we have sufficient data
  if(min(dim(cross_tab)) > 1) {
    kable(cross_tab, caption = "Cross-tabulation: Establishment Type vs Specific Activity")
    
    # Mosaic plot
    mosaicplot(cross_tab, 
               color = RColorBrewer::brewer.pal(min(8, ncol(cross_tab)), "Set3"),
               main = "Establishment Type vs Specific Activity",
               las = 2, cex.axis = 0.8)
  }
}
```

## 3.4 Correlation Analysis

```{r correlation_analysis}
# Correlation matrix for numeric variables
if(ncol(numeric_vars) > 1) {
  # Pearson correlation
  cor_pearson <- cor(numeric_vars, use = "complete.obs", method = "pearson")
  
  # Spearman correlation (more robust for non-normal data)
  cor_spearman <- cor(numeric_vars, use = "complete.obs", method = "spearman")
  
  # Visualize correlations
  library(corrplot)
  par(mfrow = c(1, 2))
  
  corrplot(cor_pearson, method = "color", type = "upper", 
           order = "hclust", tl.cex = 0.8, tl.col = "black",
           title = "Pearson Correlations", mar = c(0,0,1,0))
  
  corrplot(cor_spearman, method = "color", type = "upper", 
           order = "hclust", tl.cex = 0.8, tl.col = "black",
           title = "Spearman Correlations", mar = c(0,0,1,0))
  
  # Detailed correlation analysis using psych package
  library(psych)
  if(require(RcmdrMisc, quietly = TRUE)) {
    r_detailed <- rcorr.adjust(numeric_vars, type = "spearman", use = "complete.obs")
    corPlot(r_detailed$R$r, numbers = TRUE, stars = TRUE, diag = FALSE,
            main = "Spearman Correlations with Significance")
  }
}
```

# 4. Factor Analysis Implementation

## 4.1 Factor Analysis Diagnostics

```{r fa_diagnostics}
# Prepare data for Factor Analysis (include all numeric variables)
fa_data <- famd_data %>%
  select_if(is.numeric) %>%
  na.omit()

cat("Variables included in Factor Analysis:", paste(names(fa_data), collapse = ", "), "\n")
cat("Number of variables:", ncol(fa_data), "\n")
cat("Number of observations:", nrow(fa_data), "\n")

if(ncol(fa_data) >= 3 && nrow(fa_data) >= 20) {
  # Kaiser-Meyer-Olkin Test
  library(psych)
  kmo_result <- KMO(fa_data)
  cat("=== FACTOR ANALYSIS DIAGNOSTICS ===\n")
  cat("Overall KMO Measure:", round(kmo_result$MSA, 3), "\n")
  if(kmo_result$MSA >= 0.6) {
    cat("✓ KMO > 0.6: Factor analysis is appropriate\n")
  } else {
    cat("⚠ KMO < 0.6: Factor analysis may not be appropriate\n")
  }
  
  # Individual MSA values
  kable(data.frame(
    Variable = names(kmo_result$MSAi),
    MSA = round(kmo_result$MSAi, 3)
  ), caption = "Individual Variable MSA Values")
  
  # Bartlett's Test of Sphericity
  bartlett_result <- cortest.bartlett(fa_data)
  cat("\nBartlett's Test of Sphericity:\n")
  cat("Chi-square:", round(bartlett_result$chisq, 2), "\n")
  cat("p-value:", format(bartlett_result$p.value, scientific = TRUE), "\n")
  if(bartlett_result$p.value < 0.05) {
    cat("✓ p < 0.05: Correlation matrix is significantly different from identity\n")
  } else {
    cat("⚠ p ≥ 0.05: Variables may be independent\n")
  }
  
  # Parallel Analysis for determining number of factors
  fa.parallel(fa_data, fm = 'fa', ylabel = 'Eigenvalues',
              main = "Parallel Analysis Scree Plot")
  
} else {
  cat("Insufficient data for Factor Analysis\n")
  cat("Need at least 3 numeric variables and 20 observations\n")
}
```

## 4.2 Factor Analysis Implementation

```{r factor_analysis}
if(exists("fa_data") && ncol(fa_data) >= 3 && nrow(fa_data) >= 20) {
  
  # Determine optimal number of factors (start with 2-3 factors)
  n_factors <- min(3, ncol(fa_data) - 1)
  
  # Traditional Factor Analysis using Maximum Likelihood
  fit_ml <- factanal(fa_data, factors = n_factors, rotation = "varimax", scores = "regression")
  
  cat("=== FACTOR ANALYSIS RESULTS ===\n")
  print(fit_ml, digits = 2, cutoff = 0.3, sort = TRUE)
  
  # Alternative using psych package for more detailed output
  fit_psych <- fa(fa_data, nfactors = n_factors, fm = 'ml', rotate = 'varimax', 
                  max.iter = 100, scores = "regression")
  
  cat("\n=== FACTOR ANALYSIS SUMMARY (psych package) ===\n")
  print(fit_psych, digits = 2, cut = 0.3, sort = TRUE)
  
  # Factor loadings visualization
  if(n_factors == 2) {
    # Biplot for 2 factors
    plot(fit_ml$loadings[,1:2], type = "n", 
         main = "Factor Loadings Plot",
         xlab = paste("Factor 1 (", round(fit_psych$Vaccounted[2,1]*100, 1), "% variance)"),
         ylab = paste("Factor 2 (", round(fit_psych$Vaccounted[2,2]*100, 1), "% variance)"))
    text(fit_ml$loadings[,1:2], labels = rownames(fit_ml$loadings), cex = 0.8)
    abline(h = 0, v = 0, lty = 2, col = "gray")
  }
  
  # Factor diagram
  fa.diagram(fit_psych, main = "Factor Structure Diagram")
  
  # Variance explained
  variance_explained <- data.frame(
    Factor = paste("Factor", 1:n_factors),
    SS_Loadings = fit_psych$Vaccounted[1,],
    Proportion_Var = fit_psych$Vaccounted[2,],
    Cumulative_Var = fit_psych$Vaccounted[3,]
  )
  
  kable(variance_explained, digits = 3, 
        caption = "Variance Explained by Factors")
  
} else {
  cat("Skipping Factor Analysis due to insufficient data\n")
}
```

## 4.3 FAMD for Mixed Data Analysis

```{r famd_analysis}
# FAMD for mixed quantitative and qualitative variables
famd_input <- famd_data %>%
  select(-supply_safety_percep, -supply_bic_safety_perception) %>%
  na.omit() %>%
  # Add row numbers to ensure unique identifiers and remove any duplicate rows
  mutate(row_id = row_number()) %>%
  distinct() %>%
  # Remove the row_id column for analysis but keep unique rows
  select(-row_id)

cat("Variables included in FAMD analysis:", paste(names(famd_input), collapse = ", "), "\n")
cat("Quantitative variables:", paste(names(famd_input)[sapply(famd_input, is.numeric)], collapse = ", "), "\n")
cat("Qualitative variables:", paste(names(famd_input)[!sapply(famd_input, is.numeric)], collapse = ", "), "\n")
cat("Number of observations after removing duplicates:", nrow(famd_input), "\n")

if(nrow(famd_input) >= 20) {
  set.seed(123)
  
  # Ensure row names are unique by adding sequence numbers
  rownames(famd_input) <- paste0("obs_", 1:nrow(famd_input))
  
  famd_result <- FAMD(famd_input, 
                      ncp = 5,         # Keep 5 dimensions
                      graph = FALSE)
  
  # Extract eigenvalues and variance explained
  eigenvalues <- get_eigenvalue(famd_result)
  kable(eigenvalues, digits = 2, 
        caption = "FAMD Eigenvalues and Variance Explained")
  
  # Scree plot
  fviz_screeplot(famd_result, addlabels = TRUE, ylim = c(0, 50)) +
    labs(title = "FAMD Scree Plot: Variance Explained by Dimensions") +
    theme_minimal()
  
} else {
  cat("Insufficient complete cases for FAMD analysis\n")
}
```

## 4.4 FAMD Variable Contributions and Interpretation

```{r famd_contributions}
if(exists("famd_result")) {
  
  # Check if FAMD was successful
  tryCatch({
    # Variable contributions to dimensions
    var_contrib <- fviz_contrib(famd_result, choice = "var", axes = 1:2, top = 10) +
      labs(title = "Variable Contributions to Dimensions 1-2") +
      theme_minimal()
    
    print(var_contrib)
    
    # Variables factor map
    var_plot <- fviz_famd_var(famd_result, 
                              choice = "var",
                              col.var = "contrib",
                              gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
                              repel = TRUE) +
      labs(title = "FAMD Variable Factor Map",
           subtitle = "Color by contribution to dimensions") +
      theme_minimal()
    
    print(var_plot)
    
    # Individual biplot
    ind_plot <- fviz_famd_ind(famd_result,
                  col.ind = "cos2",
                  gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
                  repel = TRUE) +
      labs(title = "FAMD Individual Factor Map",
           subtitle = "Color by quality of representation") +
      theme_minimal()
    
    print(ind_plot)
    
    # Extract variable coordinates for interpretation
    var_coords <- get_famd_var(famd_result)
    
    # Check if we have enough dimensions
    n_dims <- min(3, ncol(var_coords$coord))
    
    kable(var_coords$coord[,1:n_dims], digits = 3,
          caption = paste("Variable Coordinates on First", n_dims, "Dimensions"))
    
    # Quality of representation
    kable(var_coords$cos2[,1:n_dims], digits = 3,
          caption = paste("Quality of Representation (cos²) - First", n_dims, "Dimensions"))
    
    # Additional interpretation tables
    cat("\n=== FAMD INTERPRETATION ===\n")
    
    # Contributions of variables to each dimension
    contrib_dim1 <- var_coords$contrib[,1]
    contrib_dim2 <- var_coords$contrib[,2]
    
    cat("Top contributors to Dimension 1:\n")
    print(head(sort(contrib_dim1, decreasing = TRUE), 5))
    
    cat("\nTop contributors to Dimension 2:\n")
    print(head(sort(contrib_dim2, decreasing = TRUE), 5))
    
  }, error = function(e) {
    cat("Error in FAMD visualization:", e$message, "\n")
    cat("This might be due to insufficient variability in the data or other data issues.\n")
  })
  
} else {
  cat("FAMD result not available for visualization\n")
}
```

# 5. Correspondence Analysis for Categorical Relationships

## 5.1 Establishment Type vs Safety Perception

```{r ca_analysis}
# Create contingency tables for key categorical relationships
if(exists("famd_input")) {
  # Filter data with valid categories
  ca_data <- famd_input %>%
    filter(!is.na(est_type), !is.na(safety_level),
           est_type != "Other", safety_level != "Unknown")
  
  cat("Data available for CA analysis:", nrow(ca_data), "observations\n")
  cat("Establishment types:", paste(unique(ca_data$est_type), collapse = ", "), "\n")
  cat("Safety levels:", paste(unique(ca_data$safety_level), collapse = ", "), "\n")
  
  if(nrow(ca_data) > 10) {  # Reduced threshold
    # Establishment type vs Safety level
    est_safety_table <- xtabs(~ est_type + safety_level, data = ca_data)
    
    cat("Contingency table dimensions:", nrow(est_safety_table), "x", ncol(est_safety_table), "\n")
    cat("Minimum cell count:", min(est_safety_table), "\n")
    
    # Display the contingency table
    kable(est_safety_table, caption = "Contingency Table: Establishment Type vs Safety Level")
    
    # Check if we have sufficient data for CA (more lenient conditions)
    if(nrow(est_safety_table) >= 2 && ncol(est_safety_table) >= 2 && sum(est_safety_table) > 0) {
      
      # Add small constant to zero cells if needed
      if(min(est_safety_table) == 0) {
        cat("Warning: Zero cells detected. Adding small constant for CA analysis.\n")
        est_safety_table_adj <- est_safety_table + 0.1
      } else {
        est_safety_table_adj <- est_safety_table
      }
      
      # Mosaic plot
      tryCatch({
        mosaicplot(est_safety_table, 
                   color = RColorBrewer::brewer.pal(min(ncol(est_safety_table), 8), "Set3"),
                   main = "Establishment Type vs Safety Perception")
      }, error = function(e) {
        cat("Could not create mosaic plot:", e$message, "\n")
      })
      
      # Chi-square test
      tryCatch({
        chi_test <- chisq.test(est_safety_table)
        cat("Chi-square test for independence:\n")
        cat("Chi-square =", round(chi_test$statistic, 3), "\n")
        cat("p-value =", format(chi_test$p.value, scientific = TRUE), "\n")
        
        if(chi_test$p.value < 0.05) {
          cat("✓ Significant association between establishment type and safety perception\n\n")
        } else {
          cat("⚠ No significant association found (p ≥ 0.05)\n\n")
        }
      }, error = function(e) {
        cat("Chi-square test failed:", e$message, "\n")
      })
      
      # Correspondence Analysis
      tryCatch({
        library(FactoMineR)
        library(factoextra)
        
        ca_result <- CA(est_safety_table_adj, graph = FALSE)
        
        # Eigenvalues
        eig_val <- get_eigenvalue(ca_result)
        kable(eig_val, digits = 3, caption = "CA Eigenvalues")
        
        # Scree plot
        scree_plot <- fviz_screeplot(ca_result, addlabels = TRUE) +
          labs(title = "CA Scree Plot: Establishment Type vs Safety")
        print(scree_plot)
        
        # Biplot
        biplot <- fviz_ca_biplot(ca_result, repel = TRUE,
                       col.row = "steelblue", col.col = "red") +
          labs(title = "Correspondence Analysis Biplot",
               subtitle = "Establishment Type vs Safety Perception") +
          theme_minimal()
        print(biplot)
        
        cat("✓ Correspondence Analysis completed successfully\n")
        
      }, error = function(e) {
        cat("Correspondence Analysis failed:", e$message, "\n")
        cat("Proceeding with basic cross-tabulation analysis instead.\n")
        
        # Alternative analysis: Simple proportions
        prop_table <- prop.table(est_safety_table, margin = 1) * 100
        kable(round(prop_table, 1), 
              caption = "Row Percentages: Safety Level by Establishment Type",
              digits = 1)
      })
      
    } else {
      cat("Insufficient data structure for Correspondence Analysis\n")
      cat("Requirements: At least 2x2 table with positive counts\n")
      
      # Fallback: Simple frequency analysis
      if(nrow(est_safety_table) > 0 && ncol(est_safety_table) > 0) {
        kable(est_safety_table, caption = "Basic Frequency Table")
        
        # Row and column totals
        row_totals <- margin.table(est_safety_table, 1)
        col_totals <- margin.table(est_safety_table, 2)
        
        cat("Establishment type frequencies:\n")
        print(row_totals)
        cat("\nSafety level frequencies:\n")
        print(col_totals)
      }
    }
  } else {
    cat("Insufficient observations for CA analysis (need > 10, have", nrow(ca_data), ")\n")
    
    # Fallback: Show basic distributions
    est_type_dist <- ca_data %>% count(est_type, sort = TRUE)
    safety_dist <- ca_data %>% count(safety_level, sort = TRUE)
    
    kable(est_type_dist, caption = "Establishment Type Distribution")
    kable(safety_dist, caption = "Safety Level Distribution")
  }
}
```

## 5.2 Product Categories vs Business Characteristics

```{r ca_products_analysis}
# Correspondence analysis for main products vs other categorical variables
if(exists("famd_input")) {
  
  # Products vs Establishment Type
  products_data <- famd_input %>%
    filter(!is.na(main_products_clean), !is.na(est_type),
           main_products_clean != "Other", est_type != "Other")
  
  cat("Products vs Establishment Type - Available data:", nrow(products_data), "observations\n")
  
  if(nrow(products_data) > 10) {  # Reduced threshold
    products_est_table <- xtabs(~ main_products_clean + est_type, data = products_data)
    
    cat("Products table dimensions:", nrow(products_est_table), "x", ncol(products_est_table), "\n")
    
    # Check if we have sufficient data
    if(nrow(products_est_table) >= 2 && ncol(products_est_table) >= 2 && sum(products_est_table) > 0) {
      
      # Display contingency table
      kable(products_est_table, caption = "Products vs Establishment Type")
      
      # Mosaic plot
      tryCatch({
        mosaicplot(products_est_table, 
                   color = RColorBrewer::brewer.pal(min(8, ncol(products_est_table)), "Set2"),
                   main = "Main Products vs Establishment Type",
                   las = 2, cex.axis = 0.7)
      }, error = function(e) {
        cat("Could not create products mosaic plot:", e$message, "\n")
      })
      
      # Chi-square test
      tryCatch({
        chi_test_products <- chisq.test(products_est_table)
        cat("Products vs Establishment Type - Chi-square test:\n")
        cat("Chi-square =", round(chi_test_products$statistic, 3), "\n")
        cat("p-value =", format(chi_test_products$p.value, scientific = TRUE), "\n")
        
        if(chi_test_products$p.value < 0.05) {
          cat("✓ Significant association between product categories and establishment types\n\n")
          
          # Correspondence Analysis for products
          if(min(products_est_table) == 0) {
            products_est_table_adj <- products_est_table + 0.1
          } else {
            products_est_table_adj <- products_est_table
          }
          
          tryCatch({
            ca_products_result <- CA(products_est_table_adj, graph = FALSE)
            
            # Biplot
            products_biplot <- fviz_ca_biplot(ca_products_result, repel = TRUE,
                           col.row = "darkgreen", col.col = "orange") +
              labs(title = "Correspondence Analysis: Products vs Establishment Type") +
              theme_minimal()
            print(products_biplot)
            
          }, error = function(e) {
            cat("CA for products failed:", e$message, "\n")
          })
          
        } else {
          cat("⚠ No significant association between products and establishment types\n")
        }
      }, error = function(e) {
        cat("Chi-square test for products failed:", e$message, "\n")
      })
    } else {
      cat("Insufficient data structure for products CA\n")
      # Show basic distribution
      products_dist <- products_data %>% count(main_products_clean, est_type) %>% arrange(desc(n))
      kable(head(products_dist, 10), caption = "Top Product-Establishment Combinations")
    }
  } else {
    cat("Insufficient observations for products analysis\n")
  }
  
  # Specific Activity vs Safety Level
  activity_safety_data <- famd_input %>%
    filter(!is.na(specific_activity_clean), !is.na(safety_level),
           specific_activity_clean != "Other", safety_level != "Unknown")
  
  cat("\nActivity vs Safety - Available data:", nrow(activity_safety_data), "observations\n")
  
  if(nrow(activity_safety_data) > 10) {
    activity_safety_table <- xtabs(~ specific_activity_clean + safety_level, data = activity_safety_data)
    
    cat("Activity table dimensions:", nrow(activity_safety_table), "x", ncol(activity_safety_table), "\n")
    
    if(nrow(activity_safety_table) >= 2 && ncol(activity_safety_table) >= 2 && sum(activity_safety_table) > 0) {
      
      # Display table
      kable(activity_safety_table, caption = "Specific Activity vs Safety Level")
      
      # Mosaic plot
      tryCatch({
        mosaicplot(activity_safety_table, 
                   color = RColorBrewer::brewer.pal(min(ncol(activity_safety_table), 8), "Set1"),
                   main = "Specific Activity vs Safety Level",
                   las = 2, cex.axis = 0.7)
      }, error = function(e) {
        cat("Could not create activity mosaic plot:", e$message, "\n")
      })
      
      # Chi-square test
      tryCatch({
        chi_test_activity <- chisq.test(activity_safety_table)
        cat("Activity vs Safety - Chi-square test:\n")
        cat("Chi-square =", round(chi_test_activity$statistic, 3), "\n")
        cat("p-value =", format(chi_test_activity$p.value, scientific = TRUE), "\n")
        
        if(chi_test_activity$p.value < 0.05) {
          cat("✓ Significant association between activity and safety\n")
        } else {
          cat("⚠ No significant association between activity and safety\n")
        }
      }, error = function(e) {
        cat("Chi-square test for activity failed:", e$message, "\n")
      })
      
    } else {
      cat("Insufficient data structure for activity CA\n")
      # Show basic distribution
      activity_dist <- activity_safety_data %>% count(specific_activity_clean, safety_level) %>% arrange(desc(n))
      kable(head(activity_dist, 10), caption = "Top Activity-Safety Combinations")
    }
  } else {
    cat("Insufficient observations for activity analysis\n")
  }
  
  # Summary of categorical relationships
  cat("\n=== CATEGORICAL RELATIONSHIPS SUMMARY ===\n")
  cat("Total observations in FAMD input:", nrow(famd_input), "\n")
  cat("- Establishment-Safety analysis:", nrow(ca_data), "observations\n")
  cat("- Products-Establishment analysis:", nrow(products_data), "observations\n") 
  cat("- Activity-Safety analysis:", nrow(activity_safety_data), "observations\n")
}
```

# 6. Advanced Clustering Analysis

## 6.1 Hierarchical Clustering

```{r hierarchical_clustering}
# Prepare data for clustering (numeric variables only)
cluster_data <- famd_data %>%
  select_if(is.numeric) %>%
  select(-supply_safety_percep, -supply_bic_safety_perception) %>%
  na.omit() %>%
  scale()  # Standardize variables

if(nrow(cluster_data) >= 10 && ncol(cluster_data) >= 2) {
  
  # Calculate distance matrix
  dist_matrix <- dist(cluster_data, method = "euclidean")
  
  # Hierarchical clustering with different linkage methods
  hc_ward <- hclust(dist_matrix, method = "ward.D2")
  hc_complete <- hclust(dist_matrix, method = "complete")
  hc_average <- hclust(dist_matrix, method = "average")
  
  # Plot dendrograms
  par(mfrow = c(2, 2))
  plot(hc_ward, main = "Ward Linkage", cex = 0.6)
  plot(hc_complete, main = "Complete Linkage", cex = 0.6)
  plot(hc_average, main = "Average Linkage", cex = 0.6)
  
  # Determine optimal number of clusters using Ward method
  # Cut tree at different levels and evaluate
  wss <- numeric(8)
  for(k in 1:8) {
    clusters <- cutree(hc_ward, k = k)
    if(k == 1) {
      wss[k] <- sum(dist_matrix^2) / (2 * nrow(cluster_data))
    } else {
      wss[k] <- sum(sapply(1:k, function(i) {
        cluster_points <- cluster_data[clusters == i, , drop = FALSE]
        if(nrow(cluster_points) > 1) {
          sum(dist(cluster_points)^2) / (2 * nrow(cluster_points))
        } else {
          0
        }
      }))
    }
  }
  
  # Plot elbow curve for hierarchical clustering
  plot(1:8, wss, type = "b", pch = 19, 
       xlab = "Number of Clusters", ylab = "Within Sum of Squares",
       main = "Elbow Method for Hierarchical Clustering")
  
  # Choose optimal k (e.g., k=3)
  optimal_k_hc <- 3
  hc_clusters <- cutree(hc_ward, k = optimal_k_hc)
  
  # Cluster analysis table
  cluster_summary_hc <- data.frame(
    Cluster = 1:optimal_k_hc,
    Size = as.numeric(table(hc_clusters))
  )
  
  kable(cluster_summary_hc, caption = paste("Hierarchical Clustering Summary (k =", optimal_k_hc, ")"))
  
} else {
  cat("Insufficient data for hierarchical clustering\n")
}
```

## 6.2 K-means Clustering with Validation

```{r kmeans_clustering}
if(exists("cluster_data") && nrow(cluster_data) >= 10) {
  
  # Determine optimal number of clusters using multiple methods
  library(factoextra)
  
  # Elbow method
  elbow_plot <- fviz_nbclust(cluster_data, kmeans, method = "wss", k.max = 8) +
    labs(title = "Elbow Method for K-means")
  
  # Silhouette method
  silhouette_plot <- fviz_nbclust(cluster_data, kmeans, method = "silhouette", k.max = 8) +
    labs(title = "Silhouette Method for K-means")
  
  # Gap statistic method
  gap_plot <- fviz_nbclust(cluster_data, kmeans, method = "gap_stat", k.max = 8) +
    labs(title = "Gap Statistic Method for K-means")
  
  # Display all plots
  library(gridExtra)
  grid.arrange(elbow_plot, silhouette_plot, gap_plot, ncol = 2)
  
  # Perform K-means with optimal k (let's use k=3 based on typical results)
  set.seed(123)
  optimal_k <- 3
  kmeans_result <- kmeans(cluster_data, centers = optimal_k, nstart = 25, iter.max = 100)
  
  # Cluster visualization
  fviz_cluster(kmeans_result, data = cluster_data,
               palette = c("#2E9FDF", "#00AFBB", "#E7B800", "#FC4E07"),
               geom = "point",
               ellipse.type = "convex",
               ggtheme = theme_bw()) +
    labs(title = paste("K-means Clustering (k =", optimal_k, ")"))
  
  # Cluster summary statistics
  cluster_centers <- data.frame(kmeans_result$centers)
  cluster_centers$Cluster <- 1:optimal_k
  cluster_centers$Size <- kmeans_result$size
  
  kable(cluster_centers, digits = 2, 
        caption = "K-means Cluster Centers and Sizes")
  
  # Silhouette analysis
  library(cluster)
  sil_width <- silhouette(kmeans_result$cluster, dist(cluster_data))
  fviz_silhouette(sil_width) +
    labs(title = "Silhouette Plot for K-means Clustering")
  
  cat("Average Silhouette Width:", round(mean(sil_width[, "sil_width"]), 3), "\n")
  
} else {
  cat("Insufficient data for K-means clustering\n")
}
```

# 7. Logistics Needs Assessment & UCC Strategy

## 7.1 Cluster-Based Logistics Profiling

```{r logistics_profiling}
if(exists("kmeans_result") && exists("famd_input")) {
  
  # Add cluster assignments to original data
  clustered_data <- famd_input[1:length(kmeans_result$cluster), ] %>%
    mutate(Cluster = factor(kmeans_result$cluster))
  
  # Analyze cluster characteristics
  cluster_profiles <- clustered_data %>%
    group_by(Cluster) %>%
    summarise(
      n = n(),
      pct = round(n() / nrow(clustered_data) * 100, 1),
      
      # Establishment type distribution
      supplier_pct = round(sum(est_type == "Supplier", na.rm = TRUE) / n() * 100, 1),
      retailer_pct = round(sum(est_type == "Retailer", na.rm = TRUE) / n() * 100, 1),
      manufacturer_pct = round(sum(est_type == "Manufacturer", na.rm = TRUE) / n() * 100, 1),
      
      # Product categories distribution
      clothing_pct = round(sum(main_products_clean == "Clothing & Textiles", na.rm = TRUE) / n() * 100, 1),
      food_pct = round(sum(main_products_clean == "Food & Beverages", na.rm = TRUE) / n() * 100, 1),
      cosmetics_pct = round(sum(main_products_clean == "Cosmetics & Beauty", na.rm = TRUE) / n() * 100, 1),
      
      # Activity types
      manufacturing_activity_pct = round(sum(specific_activity_clean == "Manufacturing", na.rm = TRUE) / n() * 100, 1),
      
      # Warehouse characteristics
      has_warehouse_pct = round(sum(has_warehouse == "Yes", na.rm = TRUE) / n() * 100, 1),
      zuap_warehouse_pct = round(sum(warehouse_in_zuap == "Yes", na.rm = TRUE) / n() * 100, 1),
      
      # Safety perception
      high_safety_pct = round(sum(safety_level == "High", na.rm = TRUE) / n() * 100, 1),
      low_safety_pct = round(sum(safety_level == "Low", na.rm = TRUE) / n() * 100, 1),
      
      .groups = 'drop'
    )
  
  kable(cluster_profiles, 
        caption = "Cluster Profiles: Logistics Characteristics")
  
  # Cluster interpretation and UCC potential
  cluster_interpretation <- cluster_profiles %>%
    mutate(
      logistics_intensity = case_when(
        supplier_pct > 50 ~ "High",
        retailer_pct > 50 ~ "Medium", 
        TRUE ~ "Low"
      ),
      
      consolidation_potential = case_when(
        has_warehouse_pct > 60 & zuap_warehouse_pct < 30 ~ "High",
        has_warehouse_pct > 40 ~ "Medium",
        TRUE ~ "Low"
      ),
      
      infrastructure_needs = case_when(
        low_safety_pct > 40 ~ "Critical",
        high_safety_pct < 30 ~ "Moderate",
        TRUE ~ "Low"
      ),
      
      ucc_priority = case_when(
        consolidation_potential == "High" & infrastructure_needs == "Critical" ~ "Priority 1",
        consolidation_potential == "High" | infrastructure_needs == "Critical" ~ "Priority 2", 
        consolidation_potential == "Medium" ~ "Priority 3",
        TRUE ~ "Priority 4"
      )
    )
  
  # UCC Implementation Strategy
  strategy_summary <- cluster_interpretation %>%
    select(Cluster, n, pct, logistics_intensity, consolidation_potential, 
           infrastructure_needs, ucc_priority)
  
  kable(strategy_summary,
        caption = "UCC Implementation Strategy by Cluster")
  
  # Visualization of cluster characteristics
  cluster_viz_data <- clustered_data %>%
    count(Cluster, safety_level) %>%
    group_by(Cluster) %>%
    mutate(pct = n / sum(n) * 100)
  
  ggplot(cluster_viz_data, aes(x = Cluster, y = pct, fill = safety_level)) +
    geom_col(position = "dodge") +
    scale_fill_brewer(type = "qual", palette = "Set2") +
    labs(title = "Safety Perception by Cluster",
         x = "Cluster", y = "Percentage (%)",
         fill = "Safety Level") +
    theme_minimal()
}
```

## 7.2 Strategic UCC Implementation Framework

```{r strategic_framework}
cat("# UCC IMPLEMENTATION STRATEGY FOR MEDELLÍN CBD\n\n")

if(exists("strategy_summary")) {
  
  # Calculate overall metrics
  total_establishments <- sum(strategy_summary$n)
  priority_1_2 <- sum(strategy_summary$n[strategy_summary$ucc_priority %in% c("Priority 1", "Priority 2")])
  high_consolidation <- sum(strategy_summary$n[strategy_summary$consolidation_potential == "High"])
  critical_infrastructure <- sum(strategy_summary$n[strategy_summary$infrastructure_needs == "Critical"])
  
  cat("## 📊 **KEY FINDINGS:**\n")
  cat("- **Total establishments analyzed:**", total_establishments, "\n")
  cat("- **Immediate UCC candidates (Priority 1-2):**", priority_1_2, 
      "(", round(priority_1_2/total_establishments*100, 1), "%)\n")
  cat("- **High consolidation potential:**", high_consolidation,
      "(", round(high_consolidation/total_establishments*100, 1), "%)\n")  
  cat("- **Critical infrastructure needs:**", critical_infrastructure,
      "(", round(critical_infrastructure/total_establishments*100, 1), "%)\n\n")
  
  cat("## 🎯 **EVIDENCE-BASED RECOMMENDATIONS:**\n\n")
  
  for(i in 1:nrow(strategy_summary)) {
    cluster_data <- strategy_summary[i,]
    cat("### **Cluster", cluster_data$Cluster, "** (", cluster_data$n, " establishments,", 
        cluster_data$pct, "%)\n")
    cat("- **Logistics Profile:** ", cluster_data$logistics_intensity, " intensity\n")
    cat("- **Consolidation Potential:** ", cluster_data$consolidation_potential, "\n") 
    cat("- **Infrastructure Needs:** ", cluster_data$infrastructure_needs, "\n")
    cat("- **UCC Priority:** ", cluster_data$ucc_priority, "\n")
    
    # Specific recommendations by priority
    if(cluster_data$ucc_priority == "Priority 1") {
      cat("- **Action:** Immediate UCC deployment with safety infrastructure\n")
    } else if(cluster_data$ucc_priority == "Priority 2") {
      cat("- **Action:** Short-term UCC inclusion with targeted interventions\n")
    } else if(cluster_data$ucc_priority == "Priority 3") {
      cat("- **Action:** Medium-term integration based on pilot results\n")
    } else {
      cat("- **Action:** Long-term consideration pending infrastructure development\n")
    }
    cat("\n")
  }
}

# Implementation phases
cat("## 📈 **PHASED IMPLEMENTATION ROADMAP:**\n\n")
cat("### **Phase 1 (0-6 months): Foundation**\n")
cat("- Deploy UCC services for Priority 1 clusters\n")
cat("- Establish basic consolidation infrastructure\n")
cat("- Address critical safety concerns with dedicated zones\n")
cat("- Develop stakeholder partnerships\n\n")

cat("### **Phase 2 (6-18 months): Expansion**\n") 
cat("- Include Priority 2 clusters in UCC network\n")
cat("- Implement smart logistics coordination systems\n")
cat("- Monitor and optimize initial performance\n")
cat("- Establish service level agreements\n\n")

cat("### **Phase 3 (18-36 months): Integration**\n")
cat("- Scale to Priority 3 clusters based on learnings\n")
cat("- Integrate with broader sustainable transport initiatives\n")
cat("- Develop cross-sector optimization\n")
cat("- Evaluate long-term sustainability\n\n")

cat("### **Phase 4 (3+ years): Optimization**\n")
cat("- Include remaining establishments based on demand\n")
cat("- Implement advanced logistics technologies\n")
cat("- Develop regional UCC network connections\n")
cat("- Achieve full LEZ logistics integration\n")
```

## 7.3 Success Metrics & Monitoring Framework

```{r success_metrics}
cat("## 📏 **SUCCESS METRICS & KPIs:**\n\n")

cat("### **Operational Efficiency:**\n")
cat("- Delivery trip reduction: Target 30-40% decrease in individual trips\n")
cat("- Consolidation rate: Target 60-70% of eligible shipments\n")
cat("- Time efficiency: Target 25% reduction in delivery times\n")
cat("- Cost effectiveness: Target 15-20% logistics cost reduction\n\n")

cat("### **Environmental Impact:**\n") 
cat("- Emissions reduction: Target 35-45% decrease in LEZ transport emissions\n")
cat("- Air quality improvement: Monitor PM2.5 and NOx levels\n")
cat("- Noise reduction: Target 20-30% decrease in delivery-related noise\n")
cat("- Energy efficiency: Track electric vehicle adoption rates\n\n")

cat("### **Safety & Infrastructure:**\n")
cat("- Safety perception improvement: Target increase from current baseline\n")
cat("- Accident reduction: Monitor delivery-related incidents\n")
cat("- Infrastructure utilization: Track loading zone efficiency\n")
cat("- Compliance rates: Monitor LEZ regulation adherence\n\n")

cat("### **Economic Viability:**\n")
cat("- Business participation: Track voluntary adoption rates\n")
cat("- Cost-benefit ratio: Maintain positive ROI for stakeholders\n")
cat("- Service quality: Monitor customer satisfaction scores\n")
cat("- Market competitiveness: Assess impact on business operations\n")
```

# 8. Research Conclusions

## 8.1 Answer to Research Question

```{r research_answer}
cat("# COMPREHENSIVE ANSWER TO RESEARCH QUESTION\n\n")
cat("**RQ: What are the specific logistics needs within CBDs and how can supply-demand alignment inform UCC implementation in LEZs?**\n\n")

if(exists("strategy_summary")) {
  cat("## 🔍 **SPECIFIC LOGISTICS NEEDS IDENTIFIED:**\n\n")
  
  # Aggregate findings across clusters
  high_needs <- sum(strategy_summary$n[strategy_summary$infrastructure_needs == "Critical"])
  consolidation_ready <- sum(strategy_summary$n[strategy_summary$consolidation_potential %in% c("High", "Medium")])
  
  cat("1. **Infrastructure Deficits:** ", high_needs, " establishments (", 
      round(high_needs/sum(strategy_summary$n)*100, 1), "%) face critical safety/infrastructure needs\n")
  cat("2. **Consolidation Opportunities:** ", consolidation_ready, " establishments (",
      round(consolidation_ready/sum(strategy_summary$n)*100, 1), "%) show medium-high consolidation potential\n")
  cat("3. **Heterogeneous Demand:** Multiple establishment types require differentiated logistics solutions\n")
  cat("4. **Safety Concerns:** Significant variation in safety perception indicates infrastructure gaps\n\n")
  
  cat("## ⚙️ **SUPPLY-DEMAND ALIGNMENT INSIGHTS:**\n\n")
  cat("1. **Cluster-Based Differentiation:** ", nrow(strategy_summary), " distinct logistics profiles require tailored UCC services\n")
  cat("2. **Priority-Based Deployment:** Evidence-based priority system enables efficient resource allocation\n")
  cat("3. **Scalable Implementation:** Phased approach allows demand-responsive UCC network growth\n")
  cat("4. **Performance Monitoring:** Data-driven metrics enable continuous supply-demand optimization\n\n")
}

cat("## 🚀 **STRATEGIC UCC IMPLEMENTATION FRAMEWORK:**\n\n")
cat("### **Evidence-Based Approach:**\n")
cat("- **Multivariate Analysis:** FAMD and clustering identify establishment patterns\n")
cat("- **Priority Matrix:** Combines consolidation potential with infrastructure needs\n")
cat("- **Phased Deployment:** Matches UCC supply with demonstrated demand\n")
cat("- **Continuous Optimization:** Monitoring framework enables adaptive management\n\n")

cat("### **Key Innovation:**\n")
cat("This study provides the first quantitative framework for UCC prioritization in CBD Low Emission Zones, ")
cat("using multivariate statistical analysis to align logistics supply with heterogeneous establishment demand patterns.\n\n")

cat("### **Policy Implications:**\n")
cat("- **Targeted Investment:** Focus initial resources on high-impact establishments\n")
cat("- **Regulatory Coordination:** Align LEZ policies with UCC deployment priorities\n")
cat("- **Stakeholder Engagement:** Use cluster profiles for targeted outreach strategies\n")
cat("- **Performance Standards:** Implement evidence-based success metrics\n")
```

---

**Analysis Methodology:** Data Quality Assessment → Factor Analysis → FAMD → Correspondence Analysis → Clustering → Strategic Framework  
**Key Innovation:** Evidence-based UCC prioritization using multivariate analysis of establishment logistics patterns  
**Data Source:** ", if(exists("famd_input")) nrow(famd_input) else "N/A", " establishments in Medellín CBD logistics survey  
**Statistical Validation:** Multiple diagnostic tests ensure analytical rigor and reliability